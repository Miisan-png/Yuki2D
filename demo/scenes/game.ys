var Y = require("stdlib.ys", "Y");
var M = require("yuki_game.ys");
var Scheduler = M.Scheduler;
var World = M.World;
var Particles = M.Particles;
var Player = require("../player.ys");

var initialized = false;
var sched;
var world;
var particles;
var player;
var font_id = -1;
var virtual_w = 640;
var virtual_h = 360;
var cam_mode;

fn wall(world, x, y, w, h, r, g, b) {
    var cid = collider_create(x, y, w, h, "wall", true);
    var e = world.spawn({
        x: x + w * 0.5,
        y: y + h * 0.5,
        tag: "wall",
        collider: { id: cid, w: w, h: h, ox: 0, oy: 0 }
    });
    e.on_draw = fn(dt, ctx, world2, self) {
        draw_rect(x, y, w, h, r, g, b, 1);
    };
    return e;
}

fn ensure_init(ctx) {
    if (initialized) return;
    initialized = true;

    set_virtual_resolution(virtual_w, virtual_h);
    ctx.pixel_snap = true;
    if (ctx.font == nil) {
        ctx.font = load_font("../assets/fonts/monogram_bitmap.png", "../assets/fonts/monogram_bitmap.json");
    }
    font_id = ctx.font;

    if (ctx.camera != nil) {
        ctx.camera.follow(true);
        ctx.camera.pixel_snap(true);
        ctx.camera.bounds(-2000, -2000, 4000, 4000);
        ctx.camera.zoom(1.0);
        ctx.camera.rot(0);
    }

    particles = Particles.create(ctx);
    world = World.create(ctx);
    player = Player.spawn(ctx, world, particles, virtual_w * 0.5, virtual_h * 0.5);
    cam_mode = {
        room_mode: false,
        smooth: false,
        pixel_snap: true,
        room_w: virtual_w,
        room_h: virtual_h
    };
    ctx.debug = { player: player, world: world, particles: particles, camera: cam_mode };

    wall(world, -120, 40, 80, 220, 0.2, 0.35, 0.5);
    wall(world, 220, 200, 160, 60, 0.2, 0.35, 0.5);
    wall(world, 120, -120, 360, 80, 0.18, 0.28, 0.4);
    wall(world, -200, -200, 60, 500, 0.18, 0.28, 0.4);

    sched = Scheduler.create(ctx);
    sched.fixed_dt = 1.0 / 60.0;
    sched.add("update", fn(dt, ctx2) {
        if (ctx2.scene != nil and ctx2.input != nil and ctx2.input.pressed("esc")) {
            ctx2.scene.push("scenes/pause.ys");
            return;
        }
        world.update(dt);
        particles.update(dt);
        if (ctx2.input != nil and ctx2.input.pressed("space")) {
            particles.emit(player.x, player.y, 40, { speed: 140, jitter: 40, life: 0.6, size: 2, r: 0.55, g: 0.78, b: 0.95, gravity: 40, drag: 2 });
            if (ctx2.camera != nil) ctx2.camera.shake(14, 0.25, 45);
        }
    });
    sched.add("fixed", fn(dt, ctx2) {
        world.fixed(dt);
    });
    sched.add("late", fn(dt, ctx2) {
        if (ctx2.camera == nil) return;
        ctx2.camera.pixel_snap(cam_mode.pixel_snap == true);
        if (cam_mode.smooth == true) {
            ctx2.camera.follow_lerp(10);
            ctx2.camera.deadzone(120, 80);
        } else {
            ctx2.camera.follow_lerp(1000);
            ctx2.camera.deadzone(0, 0);
        }
        var px = player.x;
        var py = player.y;
        if (cam_mode.pixel_snap == true) {
            px = floor(px + 0.5);
            py = floor(py + 0.5);
        }
        if (cam_mode.room_mode == true) {
            var rx = floor(px / cam_mode.room_w);
            var ry = floor(py / cam_mode.room_h);
            var cx = rx * cam_mode.room_w + cam_mode.room_w * 0.5;
            var cy = ry * cam_mode.room_h + cam_mode.room_h * 0.5;
            ctx2.camera.follow_target(cx, cy);
        } else {
            ctx2.camera.follow_target(px, py);
        }
    });
    sched.add("draw", fn(dt, ctx2) {
        set_clear_color(0.08, 0.09, 0.12);
        draw_rect(-2000, -2000, 4000, 4000, 0.07, 0.08, 0.10, 1);
        particles.draw(dt);
        world.draw(dt);
        if (font_id >= 0) {
            draw_text(font_id, "WASD move | Space burst | Tab player debug", 12, 12, "color", 0.7, 0.9, 1, 1);
        }
    });
}

exports = {
    enter: fn(prev, ctx) { ensure_init(ctx); },
    resume: fn(prev, ctx) { ensure_init(ctx); },
    update: fn(dt, ctx) {
        ensure_init(ctx);
        sched.tick(dt);
    }
};
